
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>自己动手开发一个 Web 服务器（三）-技术 ◆ 学习|Linux.中国-开源社区</title>
 
<meta name="keywords" content="自己动手开发一个 Web 服务器（三）" />
<meta name="description" content="在第二部分中，你开发了一个能够处理HTTPGET请求的简易WSGI服务器。在上一篇的最后，我问了你一个问题：怎样让服务器一次处理多个请求？读完本文，你就能够完美地回答这个问题。接下来，请你做好准备，因为本文的内容非常多，节奏也很快。文中的所有代码都可以在Github仓库下载。  首先，我们简单回忆一下简易网络服务器是如何实现的，服务器要处理客户端的请求需要哪些条件。你在前面两部分文章中开发的服务器，是一个迭代式服务器（iterative server），还只能一次处理一个客户端请求。只有在处理完当前客户端请求之后，它才能接收新的 " />
<meta name="copyright" content="2005-2015 Linux.cn" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
<meta name="applicable-device" content="pc,mobile">
<meta name="referrer" content="always">
<base href="https://linux.cn/" /><link rel="stylesheet" type="text/css" href="https://dn-linuxcn.qbox.me/data/cache/style_1_common.css?R99" />
<link rel="stylesheet" type="text/css" href="https://dn-linuxcn.qbox.me/data/cache/style_1_portal_view.css?R99" />
<link href="https://dn-linuxcn.qbox.me/static/css/responsive.css?R99" rel="stylesheet">
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?f219a1d7ae00e99bdc4410080f3a6ef7";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script type="text/javascript">var STYLEID = '1', STATICURL = 'https://dn-linuxcn.qbox.me/static/', IMGDIR = 'https://dn-linuxcn.qbox.me/static/image/common', VERHASH = 'R99', charset = 'utf-8', discuz_uid = '0', cookiepre = 'dx_516d_', cookiedomain = '.linux.cn', cookiepath = '/', showusercard = '1', attackevasive = '0', disallowfloat = '', creditnotice = '1|经验|,2|L币|,3|贡献|', defaultstyle = '', REPORTURL = 'aHR0cDovL2xpbnV4LmNuL2FydGljbGUtNjgxNy0xLmh0bWw=', SITEURL = 'https://linux.cn/', JSPATH = 'https://dn-linuxcn.qbox.me/static/js/', CSSPATH = 'data/cache/style_', DYNAMICURL = '';</script>
<script src="https://dn-linuxcn.qbox.me/static/js/common.js?R99" type="text/javascript"></script>
<script src="https://dn-linuxcn.qbox.me/static/js/jquery-1.11.0.min.js" type="text/javascript"></script>
<script type="text/javascript">jQuery.noConflict();</script>
<script src="https://dn-linuxcn.qbox.me/static/js/jquery.plugins.js?R99" type="text/javascript"></script>
<script src="https://dn-linuxcn.qbox.me/static/js/bootstrap.min.js?R99" type="text/javascript"></script>
<link rel="alternate" type="application/rss+xml" title="Linux.中国 - 开源社区 RSS" href="/rss.xml" />
<link rel="shortcut icon" href="https://dn-linuxcn.qbox.me/favicon.ico"  sizes="32x32" />
<link rel="canonical" href="https://linux.cn/article-6817-1.html" /><script src="https://dn-linuxcn.qbox.me/static/js/portal.js?R99" type="text/javascript"></script>
</head>

<body id="nv_portal" class="pg_view" onkeydown="if(event.keyCode==27) return false;">
<div id="append_parent"></div><div id="ajaxwaitid"></div>
<div id="toptb" class="cl">
<div class="wp">
<div class="z"><a href="/rss.xml" target="_blank" >RSS</a><a href="/tag/" >TAG</a><a href="http://mail.qq.com/cgi-bin/bookcol?colid=20274" >邮件列表</a><a href="http://www.qiniu.com/" target="_blank"  style="color: blue;">由七牛云存储提供图床支持</a></div>
<div class="y">
<a href="/aboutus.html" >关于我们/aboutus</a><a href="/business.html" >广告合作/AD</a></div>
</div>
</div>


<div id="hd">
<div class="wp">
<div class="hdc cl"><h2 style="padding:5px 20px 5px 0;"><a href="./" title="Linux.中国 - 开源社区"><img src="https://dn-linuxcn.qbox.me/static/image/common/linuxcn_logo_230x80_ani2.gif" alt="Linux.中国 - 开源社区" border="0" /></a></h2><div class="y"><script src="https://dn-linuxcn.qbox.me/static/js/logging.js?R99" type="text/javascript"></script>
<form method="post" autocomplete="off" id="lsform" action="member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes" onsubmit="pwmd5('ls_password');return lsSubmit();">
<div class="fastlg cl">
<span id="return_ls" style="display:none"></span>
<div class="y pns">
<table cellspacing="0" cellpadding="0">
<tr>
<td><label for="ls_username">帐号</label></td>
<td><input type="text" name="username" id="ls_username" class="px vm xg1"  value="用户名/Email" onfocus="if(this.value == '用户名/Email'){this.value = '';this.className = 'px vm';}" onblur="if(this.value == ''){this.value = '用户名/Email';this.className = 'px vm xg1';}" tabindex="901" /></td>
<td class="fastlg_l"><label for="ls_cookietime"><input type="checkbox" name="cookietime" id="ls_cookietime" class="pc" value="2592000" tabindex="903" />自动登录</label></td>
<td>&nbsp;<a href="javascript:;" onclick="showWindow('login', 'member.php?mod=logging&action=login&viewlostpw=1')">找回密码</a></td>
</tr>
<tr>
<td><label for="ls_password">密码</label></td>
<td><input type="password" name="password" id="ls_password" class="px vm" autocomplete="off" tabindex="902" /></td>
<td class="fastlg_l"><button type="submit" class="pn vm" tabindex="904"><em>登录</em></button></td>
<td>&nbsp;<a href="member.php?mod=knight" class="xi2 xw1">骑士注册</a></td>
</tr>
</table>
<input type="hidden" name="quickforward" value="yes" />
<input type="hidden" name="handlekey" value="ls" />
</div>

<div class="fastlg_fm y" style="margin-right: 10px; padding-right: 10px">
<p><a href="http://linux.cn/connect.php?mod=login&op=init&referer=portal.php%3Fmod%3Dview%26aid%3D6817%26page%3D1%26ref%3D&statfrom=login_simple"><img src="https://dn-linuxcn.qbox.me/static/image/common/qq_login.gif" class="vm" alt="QQ登录" /></a></p>
<p><a href="xwb.php?m=xwbAuth.login"><img src="https://dn-linuxcn.qbox.me/static/image/common/sina_login.gif" class="vm" style="padding: 2px 0;" alt="微博登录" /></a></p>
</div>

<script>
try{
(function(){
var node = document.getElementById("lsform").firstChild;
var i = 1;
while(i < 3 && node.nodeType!=1){
node=node.nextSibling;
i++;
}
node.style.width = 'auto';
})();
}catch(e){}
</script>
</div>
</form>

<script src="https://dn-linuxcn.qbox.me/static/js/md5.js?R99" type="text/javascript" reload="1"></script>
</div>
<h2 style="padding:5px 20px;float:right;">
<div style="margin-bottom:5px;">
    <div><a href="http://linux.cn/go/vuq" target="_blank"><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/03/105752vba0wb0wqp3eea97.png" height="80" width="300" alt="UCloud" border="0"></a></div></div>
</h2>
</div>
<div class="p_pop h_pop" id="mn_userapp_menu" style="display: none"></div><div id="topmenu_wrapper">
<div id="topmenu">
<div id="nv">
<ul><li id="mn_N6666" ><a href="/" hidefocus="true"   style="font-weight: bold;">首页</a></li><li id="mn_P3" onmouseover="navShow('P3')"><a href="https://linux.cn/tech/" hidefocus="true"   style="color: #FFFAE5;">技术 ◆ 学习</a></li><li id="mn_P1" ><a href="https://linux.cn/news/" hidefocus="true"   style="color: #FFFAE5;">新闻 ◆ 快讯</a></li><li id="mn_P4" ><a href="https://linux.cn/talk/" hidefocus="true"   style="color: #FFFAE5;">观点 ◆ 热议</a></li><li id="mn_P8" onmouseover="navShow('P8')"><a href="https://linux.cn/share/" hidefocus="true"   style="color: #FFFAE5;">软件 ◆ 分享</a></li><li id="mn_N9be8" onmouseover="navShow('N9be8')"><a href="/forum/" hidefocus="true" target="_blank"   style="color: cyan;">论坛</a></li><li id="mn_Ne749" ><a href="/forum.php?mod=post&action=newthread&fid=119" hidefocus="true" target="_blank"   style="color: red;">投稿</a></li></ul>
</div>
<div id="mu" class="cl">
<ul class="cl " id="snav_mn_P3" style="display:none;">
<li><a href="https://linux.cn/tech/desktop/" hidefocus="true" >桌面应用</a></li><li><a href="https://linux.cn/tech/sa/" hidefocus="true" >系统运维</a></li><li><a href="https://linux.cn/tech/program/" hidefocus="true" >软件开发</a></li></ul>
<ul class="cl " id="snav_mn_P8" style="display:none;">
<li><a href="https://linux.cn/share/distro/" hidefocus="true" >Linux 发行版</a></li></ul>
<ul class="cl " id="snav_mn_N9be8" style="display:none;">
<li><a href="/thread/" hidefocus="true"  style="color: blue;">全部话题</a></li><li><a href="javascript:showWindow('nav', 'forum.php?mod=misc&action=nav&special=0');" hidefocus="true"  style="color: red;">发新帖</a></li><li><a href="javascript:void();" hidefocus="true" >|</a></li><li><a href="/forum/news/" hidefocus="true" >新闻杂谈</a></li><li><a href="/forum/sa/" hidefocus="true" >系统运维</a></li><li><a href="/forum/program/" hidefocus="true" >编程开发</a></li></ul>
<ul class="cl " id="snav_mn_N39f5" style="display:none;">
<li><a href="/space.php" hidefocus="true" >首页</a></li><li><a href="/home.php?mod=space&do=home" hidefocus="true" >动态</a></li><li><a href="/home.php?mod=space&do=doing" hidefocus="true" >记录</a></li><li><a href="/home.php?mod=space&do=blog" hidefocus="true" >博客</a></li><li><a href="/home.php?mod=space&do=album" hidefocus="true" >相册</a></li><li><a href="/home.php?mod=space&do=favorite" hidefocus="true" >收藏</a></li><li><a href="/home.php?mod=space&do=friend" hidefocus="true" >好友</a></li><li><a href="/home.php?mod=spacecp&ac=invite" hidefocus="true" >邀请</a></li></ul>
<ul class="cl " id="snav_mn_userapp" style="display:none;">
</ul>
</div></div>
</div>
<div id="scbar" class="cl">
<form id="scbar_form" method="post" autocomplete="off" onsubmit="searchFocus($('scbar_txt'))" action="search.php?searchsubmit=yes" target="_blank">
<input type="hidden" name="mod" id="scbar_mod" value="search" />
<input type="hidden" name="formhash" value="4a0b8be8" />
<input type="hidden" name="srchtype" value="title" />
<input type="hidden" name="srhfid" value="0" />
<input type="hidden" name="srhlocality" value="portal::view" />
<table id="scbar_table" cellspacing="0" cellpadding="0" style="float:right;">
<tr>
<td class="scbar_icon_td"></td>
<td class="scbar_txt_td"><input type="text" name="srchtxt" id="scbar_txt" value="请注册后再搜索" autocomplete="off" speech /></td>
<td class="scbar_type_td"><a href="javascript:;" id="scbar_type" class="xg1" onclick="showMenu(this.id)" hidefocus="true">搜索</a></td>
<td class="scbar_btn_td"><button type="submit" name="searchsubmit" id="scbar_btn" sc="1" class="pn pnc" value="true"><strong class="xi2">搜索</strong></button></td>
<td class="scbar_hot_td">
<div id="scbar_hot">
</div>
</td>
</tr>
</table>
</form>
<span class="z titletext" style="padding: 0 10px 0 20px;">❏ <a href="http://locez.com" target="_blank">Locez</a> 新手指南：</span>
<ul class="cl mutag z">
<li><a class="hidefocus" hidefocus="true" href="https://linux.cn/article-4130-1.html">下载 Linux »</a></li>
<li><a class="hidefocus" hidefocus="true" href="https://linux.cn/article-5893-1.html">安装 Linux »</a></li>
<li><a class="hidefocus" hidefocus="true" href="https://linux.cn/article-6042-1.html">安装软件 »</a></li>
<li><a class="hidefocus" hidefocus="true" href="https://linux.cn/article-6160-1.html">基础命令 »</a></li>

</ul>
</div>
<br class="clear" />
<ul id="scbar_type_menu" class="p_pop" style="display: none;"><li><a href="javascript:;" rel="search">全站</a></li></ul>
<script type="text/javascript">
initSearchmenu('scbar', '');
</script>
<script type="text/javascript">
(function($){
$(window).load(function() {
$("#topmenu").affix({offset : {
top : $("#topmenu").offset().top,
bottom: 218}});
$("#topmenu").width($('.hdc').width());
$('#topmenu_wrapper').height($("#topmenu").height());

$("#search_more").affix({offset : {
top: 1000}});
})
})(jQuery);
</script>

</div>
</div>
<div id="wp" class="wp">
<script src="https://dn-linuxcn.qbox.me/static/js/forum_viewthread.js?R99" type="text/javascript"></script>
<script type="text/javascript">zoomstatus = parseInt(1), imagemaxwidth = '700', aimgcount = new Array();</script>

<div style="margin-bottom:5px;">
    <div><a href="http://linux.cn/go/vcv" target="_blank"><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201601/25/153225qd92buf78p682jbu.jpg" height="120" width="100%" border="0"></a></div></div>
<div id="pt" class="bm cl">
<div class="z">
<a href="./" class="nvhm" title="首页">Linux.中国 - 开源社区</a> <em>&rsaquo;</em><a href="https://linux.cn/tech/">技术 ◆ 学习</a> <em>&rsaquo;</em>
查看内容
</div>
</div>

<style id="diy_style" type="text/css"></style>
<div class="wp">
<!--[diy=diy1]--><div id="diy1" class="area"></div><!--[/diy]-->
</div>
<div id="ct" class="ct2 wp cl">
<div class="mn">
<div style="margin-bottom:5px;">
    </div>
<div class="vw">
<div class="h hm">
<h1 class="ph" id="article_title">自己动手开发一个 Web 服务器（三） </h1>
<p class="xg1">
2016-1-3 10:00&nbsp;&nbsp;&nbsp;
收藏: <em id="_favtimes">5</em>&nbsp;分享: <em id="_sharetimes">1</em>&nbsp;&nbsp;&nbsp;&nbsp;
</p>
<p class="copyright">
    	 
    		    			    			<span class="z textcut">编译自：<a href="http://ruslanspivak.com/lsbaws-part3/" target="_blank">http://ruslanspivak.com/lsbaws-part3/</a></span>
    			    		    		<span class="y">作者： Ruslan</span>    		<br class="clear" />
    	    	<span class="z textcut">转载自：编程派 &nbsp;&nbsp;<a href="http://codingpy.com/article/build-a-simple-web-server-part-three/" target="_blank">http://codingpy.com/article/build-a-simple-web-server-part-three/</a></span>
    		<br class="clear" />
    	    	<span class="z">本文地址：<a href="https://linux.cn/article-6817-1.html">https://linux.cn/article-6817-1.html</a></span>
    	<span class="y"><a href="https://linux.cn/article-6817-1.html?pr" class="print" title="打印"></a></span>
    	<br class="clear" />
    	</p>

</div>

<!--[diy=diysummarytop]--><div id="diysummarytop" class="area"></div><!--[/diy]-->


<!--[diy=diysummarybottom]--><div id="diysummarybottom" class="area"></div><!--[/diy]-->

<div class="d">

<!--[diy=diycontenttop]--><div id="diycontenttop" class="area"></div><!--[/diy]-->

<div id="article_content"><p>在<a href="https://linux.cn/article-6816-1.html">第二部分</a>中，你开发了一个能够处理HTTPGET请求的简易WSGI服务器。在<a href="https://linux.cn/article-6816-1.html">上一篇</a>的最后，我问了你一个问题：&ldquo;怎样让服务器一次处理多个请求？&rdquo;读完本文，你就能够完美地回答这个问题。接下来，请你做好准备，因为本文的内容非常多，节奏也很快。文中的所有代码都可以在<a href="https://github.com/rspivak/lsbaws/blob/master/part3/">Github仓库</a>下载。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/010017aupzqr724svvvfee.jpg" alt="" /></p>
<p>首先，我们简单回忆一下简易网络服务器是如何实现的，服务器要处理客户端的请求需要哪些条件。你在前面两部分文章中开发的服务器，是一个<ruby>迭代式服务器<rp>（</rp><rt>iterative server</rt><rp>）</rp></ruby>，还只能一次处理一个客户端请求。只有在处理完当前客户端请求之后，它才能接收新的客户端连接。这样，有些客户端就必须要等待自己的请求被处理了，而对于流量大的服务器来说，等待的时间就会特别长。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011326fx94xx2k2vqyk2v0.png" alt="客户端逐个等待服务器响应" /></p>
<p>下面是迭代式服务器<code>webserver3a.py</code>的代码：</p>
<pre class="prettyprint linenums"><code>#####################################################################
# Iterative server - webserver3a.py                                 #
#                                                                   #
# Tested with Python 2.7.9 &amp; Python 3.4 on Ubuntu 14.04 &amp; Mac OS X  #
#####################################################################
import socket

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 5


def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(request.decode())
    http_response = b"""\
HTTP/1.1 200 OK

Hello, World!
"""
    client_connection.sendall(http_response)


def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))

    while True:
        client_connection, client_address = listen_socket.accept()
        handle_request(client_connection)
        client_connection.close()

if __name__ == '__main__':
    serve_forever()
</code></pre>
<p>如果想确认这个服务器每次只能处理一个客户端的请求，我们对上述代码作简单修改，在向客户端返回响应之后，增加60秒的延迟处理时间。这个修改只有一行代码，即告诉服务器在返回响应之后睡眠60秒。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011327njdusebezeequ4ju.png" alt="让服务器睡眠60秒" /></p>
<p>下面就是修改之后的服务器代码：</p>
<pre class="prettyprint linenums"><code>#########################################################################
# Iterative server - webserver3b.py                                     #
#                                                                       #
# Tested with Python 2.7.9 &amp; Python 3.4 on Ubuntu 14.04 &amp; Mac OS X      #
#                                                                       #
# - Server sleeps for 60 seconds after sending a response to a client   #
#########################################################################
import socket
import time

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 5


def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(request.decode())
    http_response = b"""\
HTTP/1.1 200 OK

Hello, World!
"""
    client_connection.sendall(http_response)
    time.sleep(60)  # sleep and block the process for 60 seconds


def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))

    while True:
        client_connection, client_address = listen_socket.accept()
        handle_request(client_connection)
        client_connection.close()

if __name__ == '__main__':
    serve_forever()
</code></pre>
<p>接下来，我们启动服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3b.py
</code></pre>
<p>现在，我们打开一个新的终端窗口，并运行<code>curl</code>命令。你会立刻看到屏幕上打印出了&ldquo;Hello, World!&rdquo;这句话：</p>
<pre class="prettyprint linenums"><code>$ curl http://localhost:8888/hello
Hello, World!
</code></pre>
<p>接着我们立刻再打开一个终端窗口，并运行<code>curl</code>命令：</p>
<pre class="prettyprint linenums"><code>$ curl http://localhost:8888/hello
</code></pre>
<p>如果你在60秒了完成了上面的操作，那么第二个<code>curl</code>命令应该不会立刻产生任何输出结果，而是处于挂死（hang）状态。服务器也不会在标准输出中打印这个新请求的正文。下面这张图就是我在自己的Mac上操作时的结果（右下角那个边缘高亮为黄色的窗口，显示的就是第二个<code>curl</code>命令挂死）：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011327bxd6vdrg0wkcc800.png" alt="Mac上操作时的结果" /></p>
<p>当然，你等了足够长时间之后（超过60秒），你会看到第一个<code>curl</code>命令结束，然后第二个<code>curl</code>命令会在屏幕上打印出&ldquo;Hello, World!&rdquo;，之后再挂死60秒，最后才结束：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011335ckw36bj4whyf4hhk.png" alt="curl命令演示" /></p>
<p>这背后的实现方式是，服务器处理完第一个<code>curl</code>客户端请求后睡眠60秒，才开始处理第二个请求。这些步骤是线性执行的，或者说迭代式一步一步执行的。在我们这个实例中，则是一次一个请求这样处理。</p>
<p>接下来，我们简单谈谈客户端与服务器之间的通信。为了让两个程序通过网络进行通信，二者均必须使用套接字。你在前两章中也看到过套接字，但到底什么是套接字？</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011339vdyzoyl2hgly28ys.png" alt="什么是套接字" /></p>
<p>套接字是<ruby>通信端点<rp>（</rp><rt>communication endpoint</rt><rp>）</rp></ruby>的抽象形式，可以让一个程序通过<ruby>文件描述符<rp>（</rp><rt>file descriptor</rt><rp>）</rp></ruby>与另一个程序进行通信。在本文中，我只讨论Linux/Mac OS X平台上的TCP/IP套接字。其中，尤为重要的一个概念就是TCP<ruby>套接字对<rp>（</rp><rt>socket pair</rt><rp>）</rp></ruby>。</p>
<blockquote>
<p>TCP连接所使用的套接字对是一个<ruby>4元组<rp>（</rp><rt>4-tuple</rt><rp>）</rp></ruby>，包括本地IP地址、本地端口、外部IP地址和外部端口。一个网络中的每一个TCP连接，都拥有独特的套接字对。IP地址和端口号通常被称为一个套接字，二者一起标识了一个网络端点。</p>
</blockquote>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011347fygfd7buqvphceyg.png" alt="套接字对合套接字" /></p>
<p>因此，<code>{10.10.10.2:49152, 12.12.12.3:8888}</code>元组组成了一个套接字对，代表客户端侧TCP连接的两个唯一端点，<code>{12.12.12.3:8888, 10.10.10.2:49152}</code>元组组成另一个套接字对，代表服务器侧TCP连接的两个同样端点。构成TCP连接中服务器端点的两个值分别是IP地址<code>12.12.12.3</code>和端口号<code>8888</code>，它们在这里被称为一个套接字（同理，客户端端点的两个值也是一个套接字）。</p>
<p>服务器创建套接字并开始接受客户端连接的标准流程如下：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011359wyhbjolmjznbjjnh.png" alt="服务器创建套接字并开始接受客户端连接的标准流程" /></p>
<ol>
<li>
<p>服务器创建一个TCP/IP套接字。通过下面的Python语句实现：</p>
<p><code>listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></p>
</li>
<li>
<p>服务器可以设置部分套接字选项（这是可选项，但你会发现上面那行服务器代码就可以确保你重启服务器之后，服务器会继续使用相同的地址）。</p>
<p><code>listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</code></p>
</li>
<li>
<p>然后，服务器绑定地址。绑定函数为套接字指定一个本地协议地址。调用绑定函数时，你可以单独指定端口号或IP地址，也可以同时指定两个参数，甚至不提供任何参数也没问题。</p>
<p><code>listen_socket.bind(SERVER_ADDRESS)</code></p>
</li>
<li>
<p>接着，服务器将该套接字变成一个侦听套接字：</p>
<p><code>listen_socket.listen(REQUEST_QUEUE_SIZE)</code></p>
</li>
</ol>
<p><code>listen</code>方法只能由服务器调用，执行后会告知服务器应该接收针对该套接字的连接请求。</p>
<p>完成上面四步之后，服务器会开启一个循环，开始接收客户端连接，不过一次只接收一个连接。当有连接请求时，<code>accept</code>方法会返回已连接的客户端套接字。然后，服务器从客户端套接字读取请求数据，在标准输出中打印数据，并向客户端返回消息。最后，服务器会关闭当前的客户端连接，这时服务器又可以接收新的客户端连接了。</p>
<p>要通过TCP/IP协议与服务器进行通信，客户端需要作如下操作：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011404barksmwjawownos2.png" alt="客户端与服务器进行通信所需要的操作" /></p>
<p>下面这段示例代码，实现了客户端连接至服务器，发送请求，并打印响应内容的过程：</p>
<pre class="prettyprint linenums"><code>import socket

# create a socket and connect to a server
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('localhost', 8888))

# send and receive some data
sock.sendall(b'test')
data = sock.recv(1024)
print(data.decode())
</code></pre>
<p>在创建套接字之后，客户端需要与服务器进行连接，这可以通过调用<code>connect</code>方法实现：</p>
<pre class="prettyprint linenums"><code>sock.connect(('localhost', 8888))
</code></pre>
<p>客户端只需要提供远程IP地址或主机名，以及服务器的远程连接端口号即可。</p>
<p>你可能已经注意到，客户端不会调用<code>bind</code>和<code>accept</code>方法。不需要调用<code>bind</code>方法，是因为客户端不关心本地IP地址和本地端口号。客户端调用<code>connect</code>方法时，系统内核中的TCP/IP栈会自动指定本地IP地址和本地端口。本地端口也被称为<ruby>临时端口<rp>（</rp><rt>ephemeral port</rt><rp>）</rp></ruby>。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011414qbpbz22e386pb1ep.png" alt="本地端口&mdash;&mdash;临时端口号" /></p>
<p>服务器端有部分端口用于连接熟知的服务，这种端口被叫做<ruby>&ldquo;熟知端口&rdquo;<rp>（</rp><rt>well-known port</rt><rp>）</rp></ruby>，例如，80用于HTTP传输服务，22用于SSH协议传输。接下来，我们打开Python shell，向在本地运行的服务器发起一个客户端连接，然后查看系统内核为你创建的客户端套接字指定了哪个临时端口（在进行下面的操作之前，请先运行<code>webserver3a.py</code>或<code>webserver3b.py</code>文件，启动服务器）：</p>
<pre class="prettyprint linenums"><code>&gt;&gt;&gt; import socket
&gt;&gt;&gt; sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
&gt;&gt;&gt; sock.connect(('localhost', 8888))
&gt;&gt;&gt; host, port = sock.getsockname()[:2]
&gt;&gt;&gt; host, port
('127.0.0.1', 60589)
</code></pre>
<p>在上面的示例中，我们看到内核为套接字指定的临时端口是60589。</p>
<p>在开始回答<a href="http://codingpy.com/article/build-a-simple-web-server-part-two/">第二部分</a>最后提的问题之前，我需要快速介绍一些其他的重要概念。稍后你就会明白我为什么要这样做。我要介绍的重要概念就是<ruby>进程<rp>（</rp><rt>process</rt><rp>）</rp></ruby>和<ruby>文件描述符<rp>（</rp><rt>file descriptor</rt><rp>）</rp></ruby>。</p>
<p>什么是进程？进程就是正在执行的程序的一个实例。举个例子，当服务器代码执行的时候，这些代码就被加载至内存中，而这个正在被执行的服务器的实例就叫做进程。系统内核会记录下有关进程的信息&mdash;&mdash;包括进程ID，以便进行管理。所以，当你运行迭代式服务器<code>webserver3a.py</code>或<code>webserver3b.py</code>时，你也就开启了一个进程。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011414mkozkrqeqkxokqxe.png" alt="服务器进程" /></p>
<p>我们在终端启动<code>webserver3a.py</code>服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3b.py
</code></pre>
<p>然后，我们在另一个终端窗口中，使用<code>ps</code>命令来获取上面那个服务器进程的信息：</p>
<pre class="prettyprint linenums"><code>$ ps | grep webserver3b | grep -v grep 
7182 ttys003    0:00.04 python webserver3b.py
</code></pre>
<p>从<code>ps</code>命令的结果，我们可以看出你的确只运行了一个Python进程<code>webserver3b</code>。进程创建的时候，内核会给它指定一个进程ID&mdash;&mdash;PID。在UNIX系统下，每个用户进程都会有一个<ruby>父进程<rp>（</rp><rt>parent process</rt><rp>）</rp></ruby>，而这个父进程也有自己的进程ID，叫做父进程ID，简称PPID。在本文中，我默认大家使用的是BASH，因此当你启动服务器的时候，系统会创建服务器进程，指定一个PID，而服务器进程的父进程PID则是BASH shell进程的PID。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011418y68wv6n8w1vcqn9r.png" alt="进程ID与父进程ID" /></p>
<p>接下来请自己尝试操作一下。再次打开你的Python shell程序，这会创建一个新进程，然后我们通过<code>os.gepid()</code>和<code>os.getppid()</code>这两个方法，分别获得Python shell进程的PID及它的父进程PID（即BASH shell程序的PID）。接着，我们打开另一个终端窗口，运行<code>ps</code>命令，<code>grep</code>检索刚才所得到的PPID（父进程ID，本操作时的结果是3148）。在下面的截图中，你可以看到我在Mac OS X上的操作结果：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011507xoojtzqinjnnio20.png" alt="Mac OS X系统下进程ID与父进程ID演示" /></p>
<p>另一个需要掌握的重要概念就是<ruby>文件描述符<rp>（</rp><rt>file descriptor</rt><rp>）</rp></ruby>。那么，到底什么是文件描述符？文件描述符指的就是当系统打开一个现有文件、创建一个新文件或是创建一个新的套接字之后，返回给进程的那个正整型数。系统内核通过文件描述符来追踪一个进程所打开的文件。当你需要读写文件时，你也通过文件描述符说明。Python语言中提供了用于处理文件（和套接字）的高层级对象，所以你不必直接使用文件描述符来指定文件，但是从底层实现来看，UNIX系统中就是通过它们的文件描述符来确定文件和套接字的。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011511mh1y141k4hhlf9ff.png" alt="文件描述符" /></p>
<p>一般来说，UNIX shell会将文件描述符0指定给进程的标准输出，文件描述富1指定给进程的标准输出，文件描述符2指定给标准错误。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011538s0w2gpqt8x3writ8.png" alt="标准输入的文件描述符" width="800" /></p>
<p>正如我前面提到的那样，即使Python语言提供了高层及的文件或类文件对象，你仍然可以对文件对象使用<code>fileno()</code>方法，来获取该文件相应的文件描述符。我们回到Python shell中来试验一下。</p>
<pre class="prettyprint linenums"><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.stdin
&lt;open file '&lt;stdin&gt;', mode 'r' at 0x102beb0c0&gt;
&gt;&gt;&gt; sys.stdin.fileno()
0
&gt;&gt;&gt; sys.stdout.fileno()
1
&gt;&gt;&gt; sys.stderr.fileno()
2
</code></pre>
<p>在Python语言中处理文件和套接字时，你通常只需要使用高层及的文件/套接字对象即可，但是有些时候你也可能需要直接使用文件描述符。下面这个示例演示了你如何通过<code>write()</code>方法向标准输出中写入一个字符串，而这个<code>write</code>方法就接受文件描述符作为自己的参数：</p>
<pre class="prettyprint linenums"><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; import os
&gt;&gt;&gt; res = os.write(sys.stdout.fileno(), 'hello\n')
hello
</code></pre>
<p>还有一点挺有意思&mdash;&mdash;如果你知道Unix系统下一切都是文件，那么你就不会觉得奇怪了。当你在Python中创建一个套接字后，你获得的是一个套接字对象，而不是一个正整型数，但是你还是可以和上面演示的一样，通过<code>fileno()</code>方法直接访问这个套接字的文件描述符。</p>
<pre class="prettyprint linenums"><code>&gt;&gt;&gt; import socket
&gt;&gt;&gt; sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
&gt;&gt;&gt; sock.fileno()
3
</code></pre>
<p>我还想再说一点：不知道大家有没有注意到，在迭代式服务器<code>webserver3b.py</code>的第二个示例中，我们的服务器在处理完请求后睡眠60秒，但是在睡眠期间，我们仍然可以通过<code>curl</code>命令与服务器建立连接？当然，<code>curl</code>命令并没有立刻输出结果，只是出于挂死状态，但是为什么服务器既然没有接受新的连接，客户端也没有立刻被拒绝，而是仍然继续连接至服务器呢？这个问题的答案在于套接字对象的<code>listen</code>方法，以及它使用的<code>BACKLOG</code>参数。在示例代码中，这个参数的值被我设置为<code>REQUEST_QUEQUE_SIZE</code>。<code>BACKLOG</code>参数决定了内核中外部连接请求的队列大小。当<code>webserver3b.py</code>服务器睡眠时，你运行的第二个<code>curl</code>命令之所以能够连接服务器，是因为连接请求队列仍有足够的位置。</p>
<p>虽然提高<code>BACKLOG</code>参数的值并不会让你的服务器一次处理多个客户端请求，但是业务繁忙的服务器也应该设置一个较大的<code>BACKLOG</code>参数值，这样<code>accept</code>函数就可以直接从队列中获取新连接，立刻开始处理客户端请求，而不是还要花时间等待连接建立。</p>
<p>呜呼！到目前为止，已经给大家介绍了很多知识。我们现在快速回顾一下之前的内容。</p>
<blockquote>
<ul>
<li>迭代式服务器</li>
<li>服务器套接字创建流程（socket, bind, listen, accept）</li>
<li>客户端套接字创建流程（socket, connect）</li>
<li><ruby>套接字对<rp>（</rp><rt>Socket pair</rt><rp>）</rp></ruby></li>
<li>套接字</li>
<li><ruby>临时端口<rp>（</rp><rt>Ephemeral port</rt><rp>）</rp></ruby>与<ruby>熟知端口<rp>（</rp><rt>well-known port</rt><rp>）</rp></ruby></li>
<li>进程</li>
<li>进程ID（PID），父进程ID（PPID）以及父子关系</li>
<li><ruby>文件描述符<rp>（</rp><rt>File descriptors</rt><rp>）</rp></ruby></li>
<li>套接字对象的<code>listen</code>方法中<code>BACKLOG</code>参数的意义</li>
</ul>
</blockquote>
<p>现在，我可以开始回答第二部分留下的问题了：如何让服务器一次处理多个请求？换句话说，如何开发一个并发服务器？</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011704raqzl5khhkfk4shw.png" alt="并发服务器手绘演示" /></p>
<p>在Unix系统中开发一个并发服务器的最简单方法，就是调用系统函数<code>fork()</code>。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011705r0ix0vx4ho478l0l.png" alt="fork()系统函数调用" /></p>
<p>下面就是崭新的<code>webserver3c.py</code>并发服务器，能够同时处理多个客户端请求：</p>
<pre class="prettyprint linenums"><code>###########################################################################
# Concurrent server - webserver3c.py                                      #
#                                                                         #
# Tested with Python 2.7.9 &amp; Python 3.4 on Ubuntu 14.04 &amp; Mac OS X        #
#                                                                         #
# - Child process sleeps for 60 seconds after handling a client's request #
# - Parent and child processes close duplicate descriptors                #
#                                                                         #
###########################################################################
import os
import socket
import time

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 5


def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(
        'Child PID: {pid}. Parent PID {ppid}'.format(
            pid=os.getpid(),
            ppid=os.getppid(),
        )
    )
    print(request.decode())
    http_response = b"""\
HTTP/1.1 200 OK

Hello, World!
"""
    client_connection.sendall(http_response)
    time.sleep(60)


def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))
    print('Parent PID (PPID): {pid}\n'.format(pid=os.getpid()))

    while True:
        client_connection, client_address = listen_socket.accept()
        pid = os.fork()
        if pid == 0:  # child
            listen_socket.close()  # close child copy
            handle_request(client_connection)
            client_connection.close()
            os._exit(0)  # child exits here
        else:  # parent
            client_connection.close()  # close parent copy and loop over

if __name__ == '__main__':
    serve_forever()
</code></pre>
<p>在讨论<code>fork</code>的工作原理之前，请测试一下上面的代码，亲自确认一下服务器是否能够同时处理多个客户端请求。我们通过命令行启动上面这个服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3c.py
</code></pre>
<p>然后输入之前迭代式服务器示例中的两个<code>curl</code>命令。现在，即使服务器子进程在处理完一个客户端请求之后会睡眠60秒，但是并不会影响其他客户端，因为它们由不同的、完全独立的进程处理。你应该可以立刻看见<code>curl</code>命令输出&ldquo;Hello, World&rdquo;，然后挂死60秒。你可以继续运行更多的<code>curl</code>命令，所有的命令都会输出服务器的响应结果&mdash;&mdash;&ldquo;Hello, World&rdquo;，不会有任何延迟。你可以试试。</p>
<p>关于<code>fork()</code>函数有一点最为重要，就是你调用<code>fork</code>一次，但是函数却会返回两次：一次是在父进程里返回，另一次是在子进程中返回。当你<code>fork</code>一个进程时，返回给子进程的PID是0，而<code>fork</code>返回给父进程的则是子进程的PID。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011706t80u2002sicmujeo.png" alt="fork函数" /></p>
<p>我还记得，第一次接触并使用<code>fork</code>函数时，自己感到非常不可思议。我觉得这就好像一个魔法。之前还是一个线性的代码，突然一下子克隆了自己，出现了并行运行的相同代码的两个实例。我当时真的觉得这和魔法也差不多了。</p>
<p>当父进程<code>fork</code>一个新的子进程时，子进程会得到父进程文件描述符的副本：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011706lmmgrrr64z9rrq6q.png" alt="当父进程fork一个新的子进程时，子进程会得到父进程文件描述符的副本" /></p>
<p>你可能也注意到了，上面代码中的父进程关闭了客户端连接：</p>
<pre class="prettyprint linenums"><code>else:  # parent
    client_connection.close()  # close parent copy and loop over
</code></pre>
<p>那为什么父进程关闭了套接字之后，子进程却仍然能够从客户端套接字中读取数据呢？答案就在上面的图片里。系统内核根据文件<ruby>描述符计数<rp>（</rp><rt>descriptor reference counts</rt><rp>）</rp></ruby>来决定是否关闭套接字。系统只有在描述符计数变为0时，才会关闭套接字。当你的服务器创建一个子进程时，子进程就会获得父进程文件描述符的副本，系统内核则会增加这些文件描述符的计数。在一个父进程和一个子进程的情况下，客户端套接字的文件描述符计数为2。当上面代码中的父进程关闭客户端连接套接字时，只是让套接字的计数减为1，还不够让系统关闭套接字。子进程同样关闭了父进程侦听套接字的副本，因为子进程不关心要不要接收新的客户端连接，只关心如何处理连接成功的客户端所发出的请求。</p>
<pre class="prettyprint linenums"><code>listen_socket.close()  # close child copy
</code></pre>
<p>稍后，我会给大家介绍如果不关闭重复的描述符的后果。</p>
<p>从上面并行服务器的源代码可以看出，服务器父进程现在唯一的作用，就是接受客户端连接，<code>fork</code>一个新的子进程来处理该客户端连接，然后回到循环的起点，准备接受其他的客户端连接，仅此而已。服务器父进程并不会处理客户端请求，而是由它的子进程来处理。</p>
<p>谈得稍远一点。我们说两个事件是并行时，到底是什么意思？</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011707xwq7ek1ezcidjnd7.png" alt="并行事件" /></p>
<p>我们说两个事件是并行的，通常指的是二者同时发生。这是简单的定义，但是你应该牢记它的严格定义：</p>
<blockquote>
<p>如果你不能分辨出哪个程序会先执行，那么二者就是并行的。</p>
</blockquote>
<p>现在又到了回顾目前已经介绍的主要观点和概念。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011707r4lspli4427z6lpg.png" alt="checkpoint" /></p>
<blockquote>
<ul>
<li>Unix系统中开发并行服务器最简单的方法，就是调用<code>fork()</code>函数</li>
<li>当一个进程<code>fork</code>新进程时，它就成了新创建进程的父进程</li>
<li>在调用<code>fork</code>之后，父进程和子进程共用相同的文件描述符</li>
<li>系统内核通过描述符计数来决定是否关闭文件/套接字</li>
<li>服务器父进程的角色：它现在所做的只是接收来自客户端的新连接，<code>fork</code>一个子进程来处理该客户端的请求，然后回到循环的起点，准备接受新的客户端连接</li>
</ul>
</blockquote>
<p>接下来，我们看看如果不关闭父进程和子进程中的重复套接字描述符，会发生什么情况。下面的并行服务器（webserver3d.py）作了一些修改，确保服务器不关闭重复的：</p>
<pre class="prettyprint linenums"><code>###########################################################################
# Concurrent server - webserver3d.py                                      #
#                                                                         #
# Tested with Python 2.7.9 &amp; Python 3.4 on Ubuntu 14.04 &amp; Mac OS X        #
###########################################################################
import os
import socket

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 5


def handle_request(client_connection):
    request = client_connection.recv(1024)
    http_response = b"""\
HTTP/1.1 200 OK

Hello, World!
"""
    client_connection.sendall(http_response)


def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))

    clients = []
    while True:
        client_connection, client_address = listen_socket.accept()
        # store the reference otherwise it's garbage collected
        # on the next loop run
        clients.append(client_connection)
        pid = os.fork()
        if pid == 0:  # child
            listen_socket.close()  # close child copy
            handle_request(client_connection)
            client_connection.close()
            os._exit(0)  # child exits here
        else:  # parent
            # client_connection.close()
            print(len(clients))

if __name__ == '__main__':
    serve_forever()
</code></pre>
<p>启动服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3d.py
</code></pre>
<p>然后通过<code>curl</code>命令连接至服务器：</p>
<pre class="prettyprint linenums"><code>$ curl http://localhost:8888/hello
Hello, World!
</code></pre>
<p>我们看到，<code>curl</code>命令打印了并行服务器的响应内容，但是并没有结束，而是继续挂死。服务器出现了什么不同情况吗？服务器不再继续睡眠60秒：它的子进程会积极处理客户端请求，处理完成后就关闭客户端连接，然后结束运行，但是客户端的<code>curl</code>命令却不会终止。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011707cfd8i9c9fsf32li8.png" alt="服务器不再睡眠，其子进程积极处理客户端请求" /></p>
<p>那么为什么<code>curl</code>命令会没有结束运行呢？原因在于重复的<ruby>文件描述符<rp>（</rp><rt>duplicate file descriptor</rt><rp>）</rp></ruby>。当子进程关闭客户端连接时，系统内核会减少客户端套接字的计数，变成了1。服务器子进程结束了，但是客户端套接字并没有关闭，因为那个套接字的描述符计数并没有变成0，导致系统没有向客户端发送<ruby>终止包<rp>（</rp><rt>termination packet</rt><rp>）</rp></ruby>（用TCP/IP的术语来说叫做FIN），也就是说客户端仍然在线。但是还有另一个问题。如果你一直运行的服务器不去关闭重复的文件描述符，服务器最终就会耗光可用的文件服务器：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011708v89n7styz799vt3t.png" alt="文件描述符" /></p>
<p>按下<code>Control-C</code>，关闭<code>webserver3d.py</code>服务器，然后通过shell自带的<code>ulimit</code>命令查看服务器进程可以使用的默认资源：</p>
<pre class="prettyprint linenums"><code>$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 3842
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 3842
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</code></pre>
<p>从上面的结果中，我们可以看到：在我这台Ubuntu电脑上，服务器进程可以使用的文件描述符（打开的文件）最大数量为1024。</p>
<p>现在，我们来看看如果服务器不关闭重复的文件描述符，服务器会不会耗尽可用的文件描述符。我们在现有的或新开的终端窗口里，将服务器可以使用的最大文件描述符数量设置为256：</p>
<pre class="prettyprint linenums"><code>$ ulimit -n 256
</code></pre>
<p>在刚刚运行了<code>$ ulimit -n 256</code>命令的终端里，我们开启<code>webserver3d.py</code>服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3d.py
</code></pre>
<p>然后通过下面的<code>client3.py</code>客户端来测试服务器。</p>
<pre class="prettyprint linenums"><code>#####################################################################
# Test client - client3.py                                          #
#                                                                   #
# Tested with Python 2.7.9 &amp; Python 3.4 on Ubuntu 14.04 &amp; Mac OS X  #
#####################################################################
import argparse
import errno
import os
import socket


SERVER_ADDRESS = 'localhost', 8888
REQUEST = b"""\
GET /hello HTTP/1.1
Host: localhost:8888

"""


def main(max_clients, max_conns):
    socks = []
    for client_num in range(max_clients):
        pid = os.fork()
        if pid == 0:
            for connection_num in range(max_conns):
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect(SERVER_ADDRESS)
                sock.sendall(REQUEST)
                socks.append(sock)
                print(connection_num)
                os._exit(0)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Test client for LSBAWS.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        '--max-conns',
        type=int,
        default=1024,
        help='Maximum number of connections per client.'
    )
    parser.add_argument(
        '--max-clients',
        type=int,
        default=1,
        help='Maximum number of clients.'
    )
    args = parser.parse_args()
    main(args.max_clients, args.max_conns)
</code></pre>
<p>打开一个新终端窗口，运行<code>client3.py</code>，并让客户端创建300个与服务器的并行连接：</p>
<pre class="prettyprint linenums"><code>$ python client3.py --max-clients=300
</code></pre>
<p>很快你的服务器就会崩溃。下面是我的虚拟机上抛出的异常情况：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011708mrhmcwauygmqusya.png" alt="服务器连接过多" /></p>
<p>问题很明显&mdash;&mdash;服务器应该关闭重复的描述符。但即使你关闭了这些重复的描述符，你还没有彻底解决问题，因为你的服务器还存在另一个问题，那就是僵尸进程！</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011708hrraunlojj8jlnr8.png" alt="僵尸进程" /></p>
<p>没错，你的服务器代码确实会产生僵尸进程。我们来看看这是怎么回事。再次运行服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3d.py
</code></pre>
<p>在另一个终端窗口中运行下面的<code>curl</code>命令：</p>
<pre class="prettyprint linenums"><code>$ curl http://localhost:8888/hello
</code></pre>
<p>现在，我们运行<code>ps</code>命令，看看都有哪些正在运行的Python进程。下面是我的Ubuntu虚拟机中的结果：</p>
<pre class="prettyprint linenums"><code>$ ps auxw | grep -i python | grep -v grep
vagrant   9099  0.0  1.2  31804  6256 pts/0    S+   16:33   0:00 python webserver3d.py
vagrant   9102  0.0  0.0      0     0 pts/0    Z+   16:33   0:00 [python] &lt;defunct&gt;
</code></pre>
<p>我们发现，第二行中显示的这个进程的PID为9102，状态是Z+，而进程的名称叫做<code>&lt;defunct&gt;</code>。这就是我们要找的僵尸进程。僵尸进程的问题在于你无法杀死它们。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011709ipr3xrbw8xq2kr2g.png" alt="僵尸进程无法被杀死" /></p>
<p>即使你试图通过<code>$ kill -9</code>命令杀死僵尸进程，它们还是会存活下来。你可以试试看。</p>
<p>到底什么是僵尸进程，服务器又为什么会创建这些进程？僵尸进程其实是已经结束了的进程，但是它的父进程并没有等待进程结束，所以没有接收到进程结束的状态信息。当子进程在父进程之前退出，系统就会将子进程变成一个僵尸进程，保留原子进程的部分信息，方便父进程之后获取。系统所保留的信息通常包括进程ID、进程结束状态和进程的资源使用情况。好吧，这样说僵尸进程也有自己存在的理由，但是如果服务器不处理好这些僵尸进程，系统就会堵塞。我们来看看是否如此。首先，停止正在运行的服务器，然后在新终端窗口中，使用<code>ulimit</code>命令将最大用户进程设置为400（还要确保将打开文件数量限制设置到一个较高的值，这里我们设置为500）。</p>
<pre class="prettyprint linenums"><code>$ ulimit -u 400
$ ulimit -n 500
</code></pre>
<p>然后在同一个窗口中启动<code>webserver3d.py</code>服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3d.py
</code></pre>
<p>在新终端窗口中，启动客户端<code>client3.py</code>，让客户端创建500个服务器并行连接：</p>
<pre class="prettyprint linenums"><code>$ python client3.py --max-clients=500
</code></pre>
<p>结果，我们发现很快服务器就因为OSError而崩溃：这个异常指的是暂时没有足够的资源。服务器试图创建新的子进程时，由于已经达到了系统所允许的最大可创建子进程数，所以抛出这个异常。下面是我的虚拟机上的报错截图。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011709wazrbssszotervh9.png" alt="OSError异常" /></p>
<p>你也看到了，如果长期运行的服务器不处理好僵尸进程，将会出现重大问题。稍后我会介绍如何处理僵尸进程。</p>
<p>我们先回顾一下目前已经学习的知识点：</p>
<blockquote>
<ul>
<li>如果你不关闭重复的文件描述符，由于客户端连接没有中断，客户端程序就不会结束。</li>
<li>如果你不关闭重复的文件描述符，你的服务器最终会消耗完可用的文件描述符（最大打开文件数）</li>
<li>当你<code>fork</code>一个子进程后，如果子进程在父进程之前退出，而父进程又没有等待进程，并获取它的结束状态，那么子进程就会变成僵尸进程。</li>
<li>僵尸进程也需要消耗资源，也就是内存。如果不处理好僵尸进程，你的服务器最终会消耗完可用的进程数（最大用户进程数）。</li>
<li>你无法杀死僵尸进程，你需要等待子进程结束。</li>
</ul>
</blockquote>
<p>那么，你要怎么做才能处理掉僵尸进程呢？你需要修改服务器代码，等待僵尸进程返回其<ruby>结束状态<rp>（</rp><rt>termination status</rt><rp>）</rp></ruby>。要实现这点，你只需要在代码中调用<code>wait</code>系统函数即可。不过，这种方法并不是最理想的方案，因为如果你调用<code>wait</code>后，却没有结束了的子进程，那么<code>wait</code>调用将会阻塞服务器，相当于阻止了服务器处理新的客户端请求。那么还有其他的办法吗？答案是肯定的，其中一种办法就是将<code>wait</code>函数调用与<ruby>信号处理函数<rp>（</rp><rt>signal handler</rt><rp>）</rp></ruby>结合使用。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011709u3ilc332ew9i137h.png" alt="信号处理函数" /></p>
<p>这种方法的具体原理如下。当子进程退出时，系统内核会发送一个<code>SIGCHLD</code>信号。父进程可以设置一个信号处理函数，用于异步监测<code>SIGCHLD</code>事件，然后再调用<code>wait</code>，等待子进程结束并获取其结束状态，这样就可以避免产生僵尸进程。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011710sr5ulr5t2te35iib.png" alt="SIGCHLD信号与wait函数结合使用" /></p>
<p>顺便说明一下，异步事件意味着父进程实现并不知道该事件是否会发生。</p>
<p>接下来我们修改服务器代码，添加一个<code>SIGCHLD</code>事件处理函数，并在该函数中等待子进程结束。具体的代码见<code>webserver3e.py</code>文件：</p>
<pre class="prettyprint linenums"><code>###########################################################################
# Concurrent server - webserver3e.py                                      #
#                                                                         #
# Tested with Python 2.7.9 &amp; Python 3.4 on Ubuntu 14.04 &amp; Mac OS X        #
###########################################################################
import os
import signal
import socket
import time

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 5


def grim_reaper(signum, frame):
    pid, status = os.wait()
    print(
        'Child {pid} terminated with status {status}'
        '\n'.format(pid=pid, status=status)
    )


def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(request.decode())
    http_response = b"""\
HTTP/1.1 200 OK

Hello, World!
"""
    client_connection.sendall(http_response)
    # sleep to allow the parent to loop over to 'accept' and block there
    time.sleep(3)


def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))

    signal.signal(signal.SIGCHLD, grim_reaper)

    while True:
        client_connection, client_address = listen_socket.accept()
        pid = os.fork()
        if pid == 0:  # child
            listen_socket.close()  # close child copy
            handle_request(client_connection)
            client_connection.close()
            os._exit(0)
        else:  # parent
            client_connection.close()

if __name__ == '__main__':
    serve_forever()
</code></pre>
<p>启动服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3e.py
</code></pre>
<p>再次使用<code>curl</code>命令，向修改后的并发服务器发送一个请求：</p>
<pre class="prettyprint linenums"><code>$ curl http://localhost:8888/hello
</code></pre>
<p>我们来看服务器的反应：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011710ebbj2rvk7kjjun7u.png" alt="修改后的并发服务器处理请求" /></p>
<p>发生了什么事？<code>accept</code>函数调用报错了。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011710ebbj2rvk7kjjun7u.png" alt="accept函数调用失败" /></p>
<p>子进程退出时，父进程被阻塞在<code>accept</code>函数调用的地方，但是子进程的退出导致了<code>SIGCHLD</code>事件，这也激活了信号处理函数。信号函数执行完毕之后，就导致了<code>accept</code>系统函数调用被中断：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011711pvfelffctfewluv1.png" alt="accept调用被中断" /></p>
<p>别担心，这是个非常容易解决的问题。你只需要重新调用<code>accept</code>即可。下面我们再修改一下服务器代码（webserver3f.py），就可以解决这个问题：</p>
<pre class="prettyprint linenums"><code>###########################################################################
# Concurrent server - webserver3f.py                                      #
#                                                                         #
# Tested with Python 2.7.9 &amp; Python 3.4 on Ubuntu 14.04 &amp; Mac OS X        #
###########################################################################
import errno
import os
import signal
import socket

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 1024


def grim_reaper(signum, frame):
    pid, status = os.wait()


def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(request.decode())
    http_response = b"""\
HTTP/1.1 200 OK

Hello, World!
"""
    client_connection.sendall(http_response)


def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))

    signal.signal(signal.SIGCHLD, grim_reaper)

    while True:
        try:
            client_connection, client_address = listen_socket.accept()
        except IOError as e:
            code, msg = e.args
            # restart 'accept' if it was interrupted
            if code == errno.EINTR:
                continue
            else:
                raise

        pid = os.fork()
        if pid == 0:  # child
            listen_socket.close()  # close child copy
            handle_request(client_connection)
            client_connection.close()
            os._exit(0)
        else:  # parent
            client_connection.close()  # close parent copy and loop over


if __name__ == '__main__':
    serve_forever()
</code></pre>
<p>启动修改后的服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3f.py
</code></pre>
<p>通过<code>curl</code>命令向服务器发送一个请求：</p>
<pre class="prettyprint linenums"><code>$ curl http://localhost:8888/hello
</code></pre>
<p>看到了吗？没有再报错了。现在，我们来确认下服务器没有再产生僵尸进程。只需要运行<code>ps</code>命令，你就会发现没有Python进程的状态是Z+了。太棒了！没有僵尸进程捣乱真是太好了。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011707r4lspli4427z6lpg.png" alt="checkpoint" /></p>
<blockquote>
<ul>
<li>如果你fork一个子进程，却不等待进程结束，该进程就会变成僵尸进程。</li>
<li>使用<code>SIGCHLD</code>时间处理函数来异步等待进程结束，获取其结束状态。</li>
<li>使用事件处理函数时，你需要牢记系统函数调用可能会被中断，要做好这类情况发生得准备。</li>
</ul>
</blockquote>
<p>好了，目前一切正常。没有其他问题了，对吗？呃，基本上是了。再次运行<code>webserver3f.py</code>，然后通过<code>client3.py</code>创建128个并行连接：</p>
<pre class="prettyprint linenums"><code>$ python client3.py --max-clients 128
</code></pre>
<p>现在再次运行<code>ps</code>命令：</p>
<pre class="prettyprint linenums"><code>$ ps auxw | grep -i python | grep -v grep
</code></pre>
<p>噢，糟糕！僵尸进程又出现了！</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011711a6do6mvyvyv14ky9.png" alt="僵尸进程又出现了" /></p>
<p>这次又是哪里出了问题？当你运行128个并行客户端，建立128个连接时，服务器的子进程处理完请求，几乎是同一时间退出的，这就触发了一大波的<code>SIGCHLD</code>信号发送至父进程。但问题是这些信号并没有进入队列，所以有几个信号漏网，没有被服务器处理，这就导致出现了几个僵尸进程。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011711s6lyilkgib6tgk6i.png" alt="部分信号没有被处理，导致出现僵尸进程" /></p>
<p>这个问题的解决方法，就是在<code>SIGCHLD</code>事件处理函数使用<code>waitpid</code>，而不是<code>wait</code>，再调用<code>waitpid</code>时增加<code>WNOHANG</code>选项，确保所有退出的子进程都会被处理。下面就是修改后的代码，webserver3g.py：</p>
<pre class="prettyprint linenums"><code>###########################################################################
# Concurrent server - webserver3g.py                                      #
#                                                                         #
# Tested with Python 2.7.9 &amp; Python 3.4 on Ubuntu 14.04 &amp; Mac OS X        #
###########################################################################
import errno
import os
import signal
import socket

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 1024


def grim_reaper(signum, frame):
    while True:
        try:
            pid, status = os.waitpid(
                -1,          # Wait for any child process
                 os.WNOHANG  # Do not block and return EWOULDBLOCK error
            )
        except OSError:
            return

        if pid == 0:  # no more zombies
            return


def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(request.decode())
    http_response = b"""\
HTTP/1.1 200 OK

Hello, World!
"""
    client_connection.sendall(http_response)


def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))

    signal.signal(signal.SIGCHLD, grim_reaper)

    while True:
        try:
            client_connection, client_address = listen_socket.accept()
        except IOError as e:
            code, msg = e.args
            # restart 'accept' if it was interrupted
            if code == errno.EINTR:
                continue
            else:
                raise

        pid = os.fork()
        if pid == 0:  # child
            listen_socket.close()  # close child copy
            handle_request(client_connection)
            client_connection.close()
            os._exit(0)
        else:  # parent
            client_connection.close()  # close parent copy and loop over

if __name__ == '__main__':
    serve_forever()
</code></pre>
<p>启动服务器：</p>
<pre class="prettyprint linenums"><code>$ python webserver3g.py
</code></pre>
<p>使用客户端<code>client3.py</code>进行测试：</p>
<pre class="prettyprint linenums"><code>$ python client3.py --max-clients 128
</code></pre>
<p>现在请确认不会再出现僵尸进程了。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011711mhyh1u1gung6nr81.png" alt="不会再出现僵尸进程了" /></p>
<p>恭喜大家！现在已经自己开发了一个简易的并发服务器，这个代码可以作为你以后开发生产级别的网络服务器的基础。</p>
<p>最后给大家留一个练习题，把<a href="https://linux.cn/article-6816-1.html">第二部分</a>中的WSGI修改为并发服务器。最终的代码可以在这里查看。不过请你在自己实现了之后再查看。</p>
<p>接下来该怎么办？借用乔希&middot;比林斯（19世纪著名幽默大师）的一句话：</p>
<blockquote>
<p>要像一张邮票，坚持一件事情直到你到达目的地。</p>
</blockquote>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/011712op43zro0poh3h244.png" alt="坚持就是胜利" /></p>
</div>
</div>
<div class="b">
<div class="hm">
<a title="分享到新浪微博" href="javascript:void( share_tsina(SITEURL + 'article-6817-shareweibo.html','article_title','article_content','https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/010017aupzqr724svvvfee.jpg.large.jpg') );" class="tsina_large"></a>
<a href="javascript:void();" onmouseover="show_qrcode(event,'#qrcode', SITEURL + 'article-6817-1-wx.html');" onmouseout="show_qrcode(event,'#qrcode','');" class="weixin_large"></a>
<a title="收藏" href="home.php?mod=spacecp&amp;ac=favorite&amp;type=article&amp;id=6817&amp;handlekey=favoritearticlehk_6817" id="a_favorite" onclick="showWindow(this.id, this.href, 'get', 0);" class="fav_large" title="收藏"></a>
</div>
<p class="copyright">
    	 
    		    			    			<span class="z textcut">编译自：<a href="http://ruslanspivak.com/lsbaws-part3/" target="_blank">http://ruslanspivak.com/lsbaws-part3/</a></span>
    			    		    		<span class="y">作者： Ruslan</span>    		<br class="clear" />
    	    	<span class="z textcut">转载自：编程派 &nbsp;&nbsp;<a href="http://codingpy.com/article/build-a-simple-web-server-part-three/" target="_blank">http://codingpy.com/article/build-a-simple-web-server-part-three/</a></span>
    		<br class="clear" />
    	    	<br />
    	<span style="color:red;">本文为转载，如需再次转载，请查看源站 “<a href="http://codingpy.com/" target=_blank>编程派</a>” 的要求。如果我们的工作有侵犯到您的权益，请及时联系我们。</span>
    		<br class="clear" />
    	    	<span>文章仅代表作者的知识和看法，如有不同观点，请楼下排队<a href="javascript:void(0);" onclick="$('message').focus();">吐槽</a> :D</span>
    	<br class="clear" />
</p>


<!--[diy=diycontentbottom]--><div id="diycontentbottom" class="area"></div><!--[/diy]-->

<script src="https://dn-linuxcn.qbox.me/static/js/home.js?R99" type="text/javascript"></script>
<div id="click_div"><table cellpadding="0" cellspacing="0" class="atd">
<tr></tr>
</table>
<script type="text/javascript">
function errorhandle_clickhandle(message, values) {
if(values['id']) {
showCreditPrompt();
show_click(values['idtype'], values['id'], values['clickid']);
}
}
</script>

</div>

<!--[diy=diycontentclickbottom]--><div id="diycontentclickbottom" class="area"></div><!--[/diy]-->

<div class="o cl ptm pbm">
<a href="home.php?mod=spacecp&amp;ac=share&amp;type=article&amp;id=6817&amp;handlekey=sharearticlehk_6817" id="a_share" onclick="showWindow(this.id, this.href, 'get', 0);" title="站内分享" class="siteshare z"></a>
<a href="home.php?mod=spacecp&amp;ac=favorite&amp;type=article&amp;id=6817&amp;handlekey=favoritearticlehk_6817" id="a_favorite" onclick="showWindow(this.id, this.href, 'get', 0);" class="favorite z" title="收藏"></a>
<a href="misc.php?mod=invite&amp;action=article&amp;id=6817" id="a_invite" onclick="showWindow('invite', this.href, 'get', 0);" class="invite z" title="邀请"></a>
<a href="https://linux.cn/article-6817-1.html?pr" class="print z" title="打印"></a>
				
</div>
<div class="pren pbm cl">
<em>上一篇：<a href="https://linux.cn/article-6816-1.html">自己动手开发一个 Web 服务器（二）</a></em><em>下一篇：<a href="https://linux.cn/article-6820-1.html">在 RedHat Linux 上做性能调优</a></em></div>
</div>
</div>

<!--[diy=diycontentrelatetop]--><div id="diycontentrelatetop" class="area"></div><!--[/diy]-->

<!--[diy=diycontentrelate]--><div id="diycontentrelate" class="area"></div><!--[/diy]-->

<div style="margin-right:15px;">
<div id="add_comment" class="bm">
<div class="bm_h cl">
<h3>发表评论</h3>
</div>
<div class="bm_c pbn">
<form id="cform" name="cform" action="portal.php?mod=portalcp&ac=comment" method="post" autocomplete="off">
<div class="tedt">
<div class="area">
<textarea name="message" rows="3" class="pt" id="message" onkeydown="ctrlEnter(event, 'commentsubmit_btn');"></textarea>
</div>
</div>

<div class="mtm z"><span id="seccode_cSk00va7"></span>		
<script type="text/javascript" reload="1">updateseccode('cSk00va7', '<sec> <span id="sec<hash>" onclick="showMenu(this.id);"><sec></span><div id="sec<hash>_menu" class="p_pop p_opt" style="display:none"><sec></div>', 'portal::view');</script>
<script type="text/javascript">
(function($){
$("#cform").submit(function(e) {
if ($("#checksec_none_cSk00va7").length>0) {
alert("请输入验证码");
return false;
} else if ($("#checksec_error_cSk00va7").length>0) {
alert("验证码输入错误，请重新输入");
return false;
} else if ($("#checksec_loading_cSk00va7").length>0) {
alert("验证码验证中……");
return false;
}
});
})(jQuery);
</script>
</div>
<input type="hidden" name="portal_referer" value="https://linux.cn/article-6817-1.html#comment">
<input type="hidden" name="referer" value="https://linux.cn/article-6817-1.html#comment" />
<input type="hidden" name="id" value="0" />
<input type="hidden" name="idtype" value="" />
<input type="hidden" name="aid" value="6817">
<input id="reppid" type="hidden" name="reppid" value="">
<input type="hidden" name="formhash" value="4a0b8be8">
<input type="hidden" name="replysubmit" value="true">
<input type="hidden" name="commentsubmit" value="true" />
<p class="mtm z"><button type="submit" name="commentsubmit_btn" id="commentsubmit_btn" value="true" class="pn"><strong>评论</strong></button></p>
<br class="clear" />
</form>
</div>
</div>
</div>
<div id="comment" class="bm" style="margin-right:15px;">
<div class="bm_h cl">
<h3 class="z"><a name="comment"></a>最新评论</h3>
<h3 class="y"><a href="javascript:void(0);" class="y" style="color:#C00;" onclick="$('message').focus();">我也要发表评论</a></h3>
</div>
<div id="comment_ul" class="bm_c"></div>
</div>

<!--[diy=diycontentcomment]--><div id="diycontentcomment" class="area"></div><!--[/diy]-->
</div>
<div class="sd pph">


<div class="drag">
<!--[diy=diyrighttop]--><div id="diyrighttop" class="area"></div><!--[/diy]-->
</div>

<div style="margin-bottom:5px;">
    <div><a href="http://linux.cn/go/vuw" target="_blank"><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201602/29/013538pvq9t8vvxou9zcz7.jpg" height="100" width="350" border="0"></a></div></div>
<div style="margin-bottom:5px;">
    </div>

<!--热门评论-->

<div style="margin-bottom:5px;"></div>

<div id="right_affix" style="width:350px;">
<div style="margin-bottom:5px;">
    <div><a href="http://linux.cn/go/vun" target="_blank"><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201602/26/173134u2bbobatqu6vo6ia.jpg" height="150" width="100%" border="0"></a></div></div>

<div class="bm block">
<div class="bm_h cl">
<h3>相关阅读</h3>
</div>
<div class="bm_c pbn" id="related_tag">
<ul class="xl xl2 cl bbs pbm" id="tag"><li><a href="tag-%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
</ul>
</div>
<div class="bm_c xl xl1 cl" id="related_article">
<ul><li><em>2016-1-1</em><a href="https://linux.cn/article-6815-1.html" target="_blank">自己动手开发一个 Web 服务器（一）</a> </li>
<li><em>2016-1-2</em><a href="https://linux.cn/article-6816-1.html" target="_blank">自己动手开发一个 Web 服务器（二）</a> </li>
<li><em>2014-11-2</em><a href="article-4144-1-rel.html" target="_blank">[华章赠书]《构建高可用Linux服务器(第3版)》点评赠书</a> </li>
<li><em>2014-11-20</em><a href="article-4265-1-rel.html" target="_blank">是时候将Linux一分为二了吗？</a> </li>
<li><em>2015-1-12</em><a href="article-4647-1-rel.html" target="_blank">[图灵赠书]《24小时365天不间断服务：服务器/基础设施核心技术》点评赠书</a> </li>
<li><em>2015-1-19</em><a href="article-4707-1-rel.html" target="_blank">《24小时365天不间断服务：服务器/基础设施核心技术》点评赠书获奖名单</a> </li>
</ul>
</div>
</div>
</div>

<script type="text/javascript">
(function($){
$(window).load(function() {
// 顶部固顶菜单高度
affix_topmenu = 35;
// 可见窗口的高度
window_height = $(window).height();

// 右侧固顶区的顶部固顶条件，当滚动至此时，本区域以顶部固顶
affix_rtop = $("#right_affix").offset().top - affix_topmenu;
// 右侧固顶区的底部固顶条件，当滚动至此时，本区域以底部固顶
if ($('#comment').length) {
affix_rbottom = $('body').height() - $('#comment').offset().top - $('#comment').height() - 2;
} else {
affix_rbottom = $('body').height() - 2;
}
// 右侧固顶区的高度
affix_rheight = $("#right_affix").height();
if (window_height >= affix_topmenu + affix_rheight) {
// 可见窗口可以见到全部的右侧固顶区域时，使用顶部和底部固顶条件
affix_roffset = {top : affix_rtop, bottom: affix_rbottom};
} else {
// 否则，只使用顶部固顶条件（如果也设置了底部固顶条件，或导致闪烁）
affix_roffset = {top : affix_rtop};
}

$("#right_affix").affix({offset : affix_roffset});

// 左侧固顶区的顶部固顶条件，当滚动至此时，本区域以顶部固顶
//affix_ltop = $("#add_comment").offset().top - affix_topmenu;
//affix_loffset = {top : affix_ltop};

//$("#add_comment").affix({offset : affix_loffset});

// 文章内插图及注释

var max_width = $("#article_content").width() - 60;
var imgp = $("#article_content P IMG").parents("P");
imgp.each(function(){
$(this).addClass("article_img");
var img = $(this).find("IMG");
// 如果有图片描述
var desc = null;
if ((desc = $(this).next("P")) && desc && desc.contents() && desc.contents().first().is("EM") ) {
  					desc.addClass("article_img_desc");
  					desc_txt = desc.contents().first().text();
  					img.attr({"title":desc_txt,"alt":desc_txt});
  				} else if ((desc = img.next("BR").next("EM")) && desc.text()) {
  					var desc_txt = desc.text();
  					img.next("BR").remove();
  					img.next("EM").remove();
  					$(this).after("<p class='article_img_desc'><em>" + desc_txt + "</em></p>");
} else {
var desc_txt = img.attr("title") || img.attr("alt");
if (desc_txt != '') {
$(this).after("<p class='article_img_desc'><em>" + desc_txt + "</em></p>");
}
}
if (img.attr("width") > max_width) {
img.attr("width",'');
img.attr("height",'');
if (! img.parent("A").is("A")) {
img.css("cursor","pointer");
    img.click(function(){window.open(img.attr("src"));});
}
} else if (img.width() > max_width) {
img.css("height",parseInt(img.height() * (max_width / img.attr("width"))));
img.css("width",max_width);
if (! img.parent("A").is("A")) {
img.css("cursor","pointer");
img.click(function(){window.open(img.attr("src"));});
}
}
});

// 链接
var re_sitelink = /^https?:\/\/(www.)?linux(.net)?.cn\//i;
$("#article_content a").map(function(){
if (re_sitelink.test($(this).attr('href'))) {
if ($(this).text() == 'Linux中国') $(this).attr('href',$(location).attr('href'));
} else {
$(this).addClass("ext").attr({"rel":"external nofollow","target":"_blank"});
}
});

// 视频
$("video").map(function() {
width = $(this).attr("width");
height = $(this).attr("height");
$(this).wrap("<div class='videoContainer'></div>").parent()
.css({width: width,height : height});
});
})
})(jQuery);
</script>
<div class="drag">
<!--[diy=diy2]--><div id="diy2" class="area"></div><!--[/diy]-->
</div>


</div>
</div>


<div class="wp mtn">
<!--[diy=diy3]--><div id="diy3" class="area"></div><!--[/diy]-->
</div>
<input type="hidden" id="portalview" value="1">

<link rel="stylesheet" href="https://dn-linuxcn.qbox.me/static/js/prettify/prettify.css?R99" type="text/css" />
<script src="https://dn-linuxcn.qbox.me/static/js/prettify/prettify.min.js?R99" type="text/javascript"></script>
<script type="text/javascript">
var sourceBaseUrl = "https://dn-linuxcn.qbox.me/static/js/tinymce/plugins/prettify";
prettyPrint();
</script>	</div>


    <div id="footer">
        <p>
            <span>Linux.CN &copy; 2003-2016 Linux中国</span>
            <span class="line">|</span>
            <span>Powered by <strong>DX</strong> | 图片存储于<a href="http://www.qiniu.com/" target="_blank">七牛云存储</a></span>
        </p>
        <p>
            <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备05083684号-1</a>            京公网安备110105001595
        </p>
        <p>
        <a href="https://linux.cn/legal.html">服务条款</a> |
        除特别申明外，本站原创内容版权遵循 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank">CC-BY-NC-SA 协议规定</a></p>
        <p>
        <a href="https://linux.cn/"><img src="https://dn-linuxcn.qbox.me/static/image/common/linuxcn_logo_mini.png" align="absmiddle" /></a>
        <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><img src="https://dn-linuxcn.qbox.me/static/image/common/cc.png" align="absmiddle" /></a>
        </p>
<p>
</p>
</div>

<div id="ft" class="cl"></div>
<script src="home.php?mod=misc&ac=sendmail&rand=1458985651" type="text/javascript"></script>
<div id="scrolltop">
<span>
<a href="javascript:void();" class="wxicon" onmouseover="show_qrcode(event,'#qrcode', SITEURL + 'article-6817-1-wx.html');" onmouseout="show_qrcode(event,'#qrcode','');"></a>
<a title="分享到新浪微博" href="javascript:void( share_tsina(SITEURL + 'article-6817-1.html','article_title','article_content','https://dn-linuxcn.qbox.me/data/attachment/album/201512/30/010017aupzqr724svvvfee.jpg.large.jpg') );" class="tsina"></a>
<a title="收藏" href="home.php?mod=spacecp&amp;ac=favorite&amp;type=article&amp;id=6817&amp;handlekey=favoritearticlehk_6817" id="a_favorite" onclick="showWindow(this.id, this.href, 'get', 0);" class="favorite" title="收藏"></a>
</span>
<span hidefocus="true"><a title="返回顶部" onclick="window.scrollTo('0','0')" class="scrolltopa" ><b>返回顶部</b></a></span>
</div>
<script type="text/javascript">_attachEvent(window, 'scroll', function () { showTopLink(); });</script>
<div id="qrcode">
<p>分享到微信朋友圈</p>
<div id="canvas"></div>
<p><em>打开微信，点击底部的“发现”，<br />
使用“扫一扫”将网页分享至朋友圈。</em></p></div>
</body>
</html>
