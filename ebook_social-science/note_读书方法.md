### 深入理解计算机系统
这是一份地图，而不是一个世界。

先整体看下目录
第一章 计算机系统的漫游 	
第一部分 程序结构和执行 	
第二部分 在系统上运行程序 	
第三部分 程序间的交互和通信 	

显而易见主要分为四部分 	
第一章 犹如一个老练的导游，以一个简单的例子为起点，简单的介绍了下这个世界的全景。 	

第一部分 介绍这个世界的地理结构。 	
硬件系统对程序运行的支持，好比世界的地理环境对于社会存在的意义。 	

第二部分 介绍这个世界的文明演化 	
链接描述了文化的继承与延续 	
异常控制流描述了文化的起承转合 	
虚拟存储器描述了文化演化的主要场地(欠佳，没有更好对比了) 	

第三部分 介绍这个世界的社会场景 	
系统级IO犹如物质的存储与使用 	
网络编程犹如四通八达的交通网络 	
并发编程犹如个体(个人，家庭，企业)的相互交互 	

整个计算机系统就像一个世界，有地理环境(硬件结构)，社会组织(并发编程,网络编程,系统IO),文明的演化 	 		
(链接，异常控制流，虚拟存储器)。这个世界如此的逼真，以至于我深陷其中不能自拔。每当做梦的时候， 			
我才发现这只是个地图，而不是一个世界。 	

这是一份地图，而不是一个世界。

作者：Code Diy
链接：https://www.zhihu.com/question/31569606/answer/52746280
来源：知乎
****************************************************
读这本书需要一点铺垫的内容			
1.有点汇编基础，能大概知道一条条汇编指令是怎么执行的。参考书，王爽的《汇编语言》 	
2.c语言基础就不说了吧，这方面参考书比较多，新手的话还是推荐c语言三件套，和《c程序设计语言》这本书 	
3.计算机表示数据那章基本上是计算机组成原理的内容，讲得还可以，感觉不需要另外的参考书籍。 	
4.编译的那章推荐一本书做铺垫，是国人攒的一本书，《程序员的自我修养》 	
5.涉及操作系统的那部分，参考《现代操作系统》这本书 	
6.计算机网络那部分参考《计算机网络-自顶向下方法》 	
这些书基本上看一轮的话一本要一周的时间，我基本上用了两个月时间完成了上面的所有书，因为要应付考试， 	
另外参考一些吴军写的书会加深理解。 	

作者：lee xeal
链接：https://www.zhihu.com/question/20354069/answer/72718810
来源：知乎
******************************************************
NB学校的NB课程的NB教材——CSAPP
figure9   

　　CMU是全美以至全球公认的CS最猛的大学之一，没办法，作为CS的发源地，再加上三位神一样的人先后在此任教：Alan Perlis（CS它祖宗+第一届Turing奖获得者）、Allen Newell（AI缔造者+Turing奖获得者）和Herbert Simon（AI缔造者+Turing奖获得者+Nobel经济学奖获得者，当代的Leibniz，偶佩服到死的一个天神下凡级的人物，他的自传 Models of my life偶特意珍藏了两本），三位巨头培养出一大摊小神级别的人物，这一大摊小神级的人物又培养出一大坨天才级人物（其中就有跳槽猥琐男开复哥）。
　　
　　偶估计那个钢铁猥琐男和银行经管男在投资时肯定不会想到，这个以他们名字命名的破烂学院在未来会如此NB，尤其还是在CS这个上如此NB。
　　
　　NB学校，自然用NB教材，更何况是CS里非常重要的计算机导论，而CMU的计算机导论教材就是CMU计算机系主任的作品：CSAPP。
　　
　　
　　CSAPP全称Computer Systems A Programmer's perspective，国内通常的书名翻译是《深入理解计算机系统》（然而偶认为这本书叫做《程序员所需要了解的计算机知识》更为合适）。
　　
　　偶在本科时曾经有过一个疑问，那就是作为一个程序员，究竟需要对计算机的硬件了解到什么程度呢，或者说，算法、数据结构和程序设计语言之外的东东，我们是否有必要了解，需要了解到什么程度呢？
　　
　　 * 至今记得学习计算机组成原理时，老师在上面拿着某个疑似打字机的东东给我们一顿演示，说这就是什么可编程逻辑器件，然后给我们展示了各种电路图，总之偶是看不明白，也想不明白这些与非门或非门异或门***门xx门会对偶编程序有什么帮助，所以这门课后来偶压根就听过，反正听也听不懂，听懂了也用不上（至少偶当时是这么想的）。
　　 * 之后学习编译原理，偶承认写个语法制导的小型翻译器是挺磨练人的编程水平的，但符号流，语法制导，语义分析这些东东实际中的效用有多大，偶真没感觉到。至少偶身边没人用语法制导写interpreter，编译原理对偶的作用就是大大简化了学正则表达式的过程，除此之外，别无它用（别鄙视偶）。
　　 * 至于操作系统，偶学完了之后脑子中除了进程和局部性这两个概念之外，可以说是一片空白，偶觉得，既然OS的设计初衷就是为程序员提供一个可编程易理解的通用接口，那我们为什么还得去把这个接口扒开然后去研究诸如硬盘的磁道有几圈寻道时间有几毫秒此类的问题，a fucking waste of time。
　　
　　即使是在CS中，80/20原则依然适用，程序员平时用到的超过九成的计算机知识基本来自于这些计算机核心课程中的不到一成的内容，至于剩下的九成内容，虽然不至于没用，然而它们没有大用，至少，它们不会对你造成什么损害。举个例子，你可以不知道DMA的原理，不知道BNF范式，你依然可以编出不错的程序；但是如果你连内存布局分配或是同步限制区都不清楚的话，那就囧大了，要不然你就会在为什么不能初始化一个大小为16MB的局部变量这样的 NC问题上纠结半天，或者是对着多线程程序里变幻莫测的全局变量百思不得其解。
　　所以说CMU的两位作者以及CSAPP这本书背后的劳动者和贡献者是非常NB的，他们非常巧妙的把程序设计及优化、数字电路基础、指令集体系、汇编语言、存储器体系结构、链接与装载、进程、虚存这一摊来自各不同的学科的核心知识点搅和在一起，并以程序员的视角呈现，所以这本书的书名叫A programmer's perspective。
　　
　　曾经有人说过这本书名（指的是中文译名）不副实，讲解的并不深入。的确，这本书虽然涉及了计算机学科的各个方面，然而很多东西都是点到为止的感觉，作者的意思也很明确，这本书属于导论的性质（CSAPP对应CMU的 Introduction to computer systems这门本科课程，属于导论性质）。按照国内CS的课程安排的话，CSAPP介于计算机组成原理和操作系统之间，它的目的就是让你对这些计算机的基础学科有一个Overview，并尽可能的把作为一个程序员所必须了解的那些essence：那不到一成的计算机核心知识，尽早的灌输给你。
　　
　　接下来聊聊偶阅读CSAPP的体会：
　　
　　 * 这本书的简介（引言）部分简介明了：一个简单的hello world程序在计算机上的执行过程，预处理->编译->汇编->链接->生成可执行目标文件->载入内存->数据流->屏幕输出显示，没有一句废话，简介扼要，总结成一句：计算机系统=位+上下文。
　　 * 关于二进制的内容个人感觉有些冗余，这部分内容偶基本是一扫而过，毕竟从小到大这些内容学了都快有十多遍了，而平时编程真能用到的二进制技巧基本也就移位和bit flag这两招。不过这章里有不少small tricks值得一耍（最经典的就是不用临时变量交换两个数）。话说回来，真要想在二进制上玩出花来，参考Hacker's delight会有更大的惊喜。
　　 * 程序的机器级表示这一章偶花了不少时间阅读，毕竟偶没学过汇编，基础基本为0。不过这本书里出现的汇编指令绝大多数都由运算、取数存数、跳转这三种指令所组成，所以在阅读上不会存在任何难度。
　　这部分融合了程序员所需了解的编译和汇编这两样课程中的基础知识：想知道for、do..while、while三种循环的实质性区别？想知道多重if和 switch的本质区别？想知道数组的存储方式？想知道数组下标读取和指针读取的区别？想知道递归过程调用的背后实现机理？看看这一章，相信你会对C语言乃至程序设计语言有更深的理解。
　　 * 指令集&体系结构这一章，两位作者为了让读者更好的理解指令集（X86），别具一格的搞出了一个简化版的Y86指令集，并用其表示基本的运算和控制，甚至连数字电路的HCL都来了一笔（暴汗）。数据流、组合逻辑和流水线，图示+详细的讲解，一目了然。国内的计组教科书应该多借鉴一下。
　　 * 程序性能优化这一章对程序员尤其实用，毕竟，正如TDD和XP的开创者Kent Beck所说，make it run, make it right, make it fast。而第三步又是最麻烦的一步，确认和消除性能的瓶颈，有时比Debug还要恐怖，所以Knuth大神说：Premature optimization is the source of evil。
　　 CSAPP通过展示一个简单的连续数求和和求积运算的小程序，通过性能监测，一步步的优化性能：减少过程调用、消除无关存储器引用、将下标引用切换到指针这些还是比较好理解的，然而后面的根据指令集展开循环、通过指令集来编写更具并行性的代码以及转移预测代价这些机器相关的优化的东东就开始颠覆我的世界观了，原来程序还可以这么搞，I服了U。
　　 唯一的遗憾就是这章的篇幅有些短小，对程序员最为重要的机器无关的程序优化介绍的也并不充分，与此相比，偶感觉programming pearls和practice of programming里面对性能优化的介绍更胜一筹。
　　 * 存储器体系结构的内容用五个字概括就是：利用局部性。
　　只有了解了计算机的梯形存储器体系结构，才能体会到为什么同样逻辑的程序会产生如此之大的性能差距，虽然计算机设计者的初衷是把存储器当成一个巨型数组。然而这个大号数组的不同体位的差距还是非常大地，搞不好就郁闷鸟。尤其是DRAM-Disk这一段，足足10的六次方的差距，所以CSAPP专门开了VM 一章来详细讲述。
　　 * 链接这部分内容篇幅不多，原理上讲的很简洁，文件节和符号解析表只是给出了几个图示，并没有过多的关注其实现。CSAPP把重点放在了链接对源代码产生的影响，同时也让偶再次理解到了全局变量很邪恶。动态链接部分让偶恍然大悟，.net里面的反射和程序集，放到C里面就是动态调用和共享库，都是相通的，无非C的代码更诡异一些。
　　 * 异常控制流这一章的名字比较囧，以至于我刚开始认为它会介绍点诸如try...catch的异常处理机制。然而看了才明白，它介绍的是更为广义的exception，既包括硬件中断，也包括故障中断，比如说陷入（trap）和故障（fault）。
　　这一章做的比较绝的是，通过讲述异常流，引入了OS中最核心的概念：进程。然而它并不在进程的具体特性上下文章，而是通过讲述unix下进程相关的api 及使用，从一种程序员的角度告诉你，进程是这么用的，进程之间是这么交换信息的。到最后捎带介绍了一下C里面的非局部跳转（更加强大的Goto，也就是 setjmp和longjmp），别以为只有C++和Java才有异常处理机制，C一样可以做到。
　　 * 程序的时间度量这一章感觉用处不大，遂跳过
　　 * 虚拟内存这一章从原理和实现两个不同的层面介绍了存储器体系结构的核心部分：VM。说实话，之前学习VM顶多就是冲着局部性去的，但没想到VM可以做的事有这么多，无论是存储器磁盘映射，还是malloc在磁盘上分配空间返回地址至PTE，都让偶对VM有了一个崭新的认识，原来VM还可以这么用。为了帮助读者深入理解内存的分配机制，作者甚至搞出了一个malloc的实现，从源代码来讲解内存分配、碎片合并、垃圾回收这些概念，帅气。
　　 * 系统级IO，网络编程以及并发编程这些东东打算之后再慢慢研究，遂跳过
　　
　　当然，要想深入学习的话，好书有的是，OS有Tanenbaum老爷子的Modern operating systems，计组有Stanford校长的量化研究和软/硬接口，编译自然就是Aho的龙书，链接可以参考Levine的 Linkers&Loaders，程序设计语言原理可以阅读Scott的Programming language pragmatics。如果需要更多的资源，可以参考CSAPP书后的Bibilography。
　　
　　说实话，放低要求的话，CSAPP已经做的相当不错了。换句话说，把这本书看明白，作为程序员应该了解的OS、编译和机组的核心理论也就明白的差不多了。同时，鉴于现在越来越多的程序员还纠结在C#/Java这样的层次上，CSAPP已经相当相当相当的深入了，:-)
　　
　　PS: 这本书刚刚出了第二版，不少内容都有更新，希望国内尽早引进。
　　
　　Acronyms:
　　
　　 * CS=Computer Science
　　 * CMU= Carnegie Mellon University
　　 * CSAPP=Computer Systems A Programmer's perspective
　　 * VM= Virtual Memory
　　 * PTE= Page Table Entry
　　
　　
　　最后补充几句，拜托豆瓣上的各位大侠做书评时，好歹把书看一遍在评论，首先别人云亦云的，他捧你也捧，他砸你也砸的；其次，别就写那么一两句套话，诸如"这本书写的很精彩"这类的话，写了还不如不写；最后，书最重要的是内容，不是纸张开本这些参数，所以请别上来就直接拿书的纸张开涮，就算是要开涮也好歹介绍下书的内容，这是书评，不是纸评，thanks。
